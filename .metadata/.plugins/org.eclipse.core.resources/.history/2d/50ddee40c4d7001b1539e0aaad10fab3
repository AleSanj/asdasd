/*
 * conexion.c
 *
 *  Created on: 5 may. 2021
 *      Author: utnso
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include "conexion.h"

/*
 * Creo el enum para no tener que pensar si devuelvo un "uno" o un "cero""
 */
typedef enum{
	ERROR,
	OK

}RESPUESTA;


//#define PUERTO "6667"
#define BACKLOG 5			// Define cuantas conexiones vamos a mantener pendientes al mismo tiempo
#define PACKAGESIZE 1024	// Define cual va a ser el size maximo del paquete a enviar


void ejemplo(){
    printf("Ejemploo");
}


int crear_server(char* puerto,char* ip){


	struct addrinfo hints;
	struct addrinfo *serverInfo;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;		// No importa si uso IPv4 o IPv6
	hints.ai_flags = AI_PASSIVE;		// Asigna el address del localhost: 127.0.0.1
	hints.ai_socktype = SOCK_STREAM;	// Indica que usaremos el protocolo TCP

	getaddrinfo(NULL, puerto, &hints, &serverInfo);

	/*for (p=servinfo; p != NULL; p = p->ai_next)
    {
        if ((socket_servidor = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1)
            continue;

        int activado = 1;
        setsockopt(socket_servidor,SOL_SOCKET,SO_REUSEADDR,&activado,sizeof(activado));

        if (bind(socket_servidor, p->ai_addr, p->ai_addrlen) == -1) {
            close(socket_servidor);
            continue;
        }
        break;
    }*/

	int listenningSocket;

	listenningSocket = socket(serverInfo->ai_family, serverInfo->ai_socktype, serverInfo->ai_protocol);

	bind(listenningSocket,serverInfo->ai_addr, serverInfo->ai_addrlen);
	freeaddrinfo(serverInfo);
	printf("Servidor creado, esperando clientes\n");
	return listenningSocket;
}

int esperar_cliente(int socket_server, int backlog){
	listen(socket_server, backlog);

	int socket_cliente;

	struct sockaddr direccion_cliente;
	socklen_t tamanio_direccion_cliente = sizeof(direccion_cliente);

	socket_cliente = accept(socket_server, (struct sockaddr *)&direccion_cliente, &tamanio_direccion_cliente);
	if (socket_cliente == -1) {
		puts("El cliente no se pudo conectar");
	exit(EXIT_FAILURE);
}

	printf("Nuevo cliente conectado con el socket: %d \n",socket_cliente);
	return socket_cliente;


}

int crear_conexion(char* ip, char* puerto)
{
	struct addrinfo hints;
	struct addrinfo *server_info;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;

	getaddrinfo(ip, puerto, &hints, &server_info);

	int socket_cliente = socket(server_info->ai_family, server_info->ai_socktype, server_info->ai_protocol);

	if(connect(socket_cliente, server_info->ai_addr, server_info->ai_addrlen) == -1)
		printf("error");

	freeaddrinfo(server_info);

	return socket_cliente;
}

t_paquete* recibir_paquete(int socket_cliente, int* respuesta) {
	t_paquete* aux_paquete = crear_paquete(-1);

	uint8_t aux_cod;
	uint32_t aux_tamanio;
	void* aux_stream = NULL;

	//puts("tratando de recibir el paquete\n");
	if (recv(socket_cliente, &(aux_cod), sizeof(int), 0) <= 0) {
		*respuesta = ERROR;
		send(socket_cliente, &respuesta, sizeof(int), 0);
		return aux_paquete;
	}


	if (recv(socket_cliente, &(aux_tamanio), sizeof(int), 0) <= 0) {
		*respuesta = ERROR;
		send(socket_cliente, &respuesta, sizeof(int), 0);
		return aux_paquete;
	}

	aux_stream = malloc(aux_tamanio);
	if (recv(socket_cliente, aux_stream, aux_tamanio, 0) <= 0) {
		*respuesta = ERROR;
		send(socket_cliente, &respuesta, sizeof(int), 0);
		return aux_paquete;
	}
	*respuesta = OK;
	send(socket_cliente, respuesta, sizeof(int), 0); // aca le enviamos un mensaje (un uno) al cliente, informandole que recibimos la info correctamente

	aux_paquete->codigo_operacion = (uint8_t)aux_cod;
	aux_paquete->buffer->size = (uint32_t) aux_tamanio;

	aux_paquete->buffer->stream = aux_stream;
	return aux_paquete;
}

t_paquete* crear_paquete(CODE_OP codigo) {
  t_paquete* paquete = malloc(sizeof(t_paquete));
  paquete->codigo_operacion = (uint8_t )codigo;
  crear_buffer(paquete);
  return paquete;
}

void crear_buffer(t_paquete* paquete) {
  paquete->buffer = malloc(sizeof(t_buffer));
  paquete->buffer->size = 0;
  paquete->buffer->stream = NULL;
}

int enviar_paquete(t_paquete* paquete, int socket_cliente) {
  int bytes = paquete->buffer->size + 3 * sizeof(int);
  void* a_enviar = serializar_paquete(paquete, bytes);
  int respuesta = ERROR;

  if (send(socket_cliente, a_enviar, bytes, 0) > 0) {  // Que pasa si quiero enviar 6 bytes y el send me devuleve 5?, tendria que tirar error?
    log_info(logger, "Paquete enviado");
    recv(socket_cliente, &respuesta, sizeof(int),0);  // Recordar que aca se puede recibir cualquier estructura que se necesite, en este caso recibimos un int con el que verificamos que se envio \todo correctamente
    if (respuesta) {
      log_info(logger, "Respuesta recibida");

    } else {
      log_info(logger, "No recibimos respuesta del servidor");
      eliminar_paquete(paquete);
    }
  } else {
    log_info(logger, "No se pudo enviar el paquete");
    eliminar_paquete(paquete);
  }
  return respuesta;
}

void liberar_conexion(int socket_cliente)
{
	close(socket_cliente);
}


